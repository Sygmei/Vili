#pragma once

#include <variant>

#include <vili/config.hpp>
#include <vili/exceptions.hpp>
#include <vili/nodes/node.hpp>

namespace vili
{
    /**
     * \brief A terminal Node that contains data (One of the types defined in vili::DataType)
     */
    class DataNode : public Node
    {
    protected:
        std::variant<int64_t, double, bool, std::string> m_data;

    public:
        const static types::node Type = types::node::data;

        DataNode();
        DataNode(const DataNode& copy);
        ~DataNode() override = default;

        void set(int64_t value);
        void set(double value);
        void set(const std::string& value);
        void set(std::string_view value);
        void set(bool value);

        DataNode& operator=(int64_t value);
        DataNode& operator=(double value);
        DataNode& operator=(const std::string& value);
        DataNode& operator=(const char* value);
        DataNode& operator=(bool value);

        void autoset(const std::string& rawData);
        [[nodiscard]] types::data data_type() const;
        template <class T> T as() const
        {
        }

        [[nodiscard]] std::string dump() const override;

        operator std::string() const;
        operator unsigned int() const;
        operator int() const;
        operator int64_t() const;
        operator double() const;
        operator bool() const;
    };

    std::ostream& operator<<(std::ostream& stream, const DataNode& node);

    template <> inline int64_t DataNode::as() const
    {
        if (std::holds_alternative<int64_t>(m_data))
            return std::get<int64_t>(m_data);
        if (PERMISSIVE_CAST && std::holds_alternative<double>(m_data))
            return std::get<double>(m_data);
        throw exceptions::invalid_cast(
            types::int_type, types::to_string(data_type()), EXC_INFO);
    }

    template <> inline double DataNode::as() const
    {
        if (std::holds_alternative<double>(m_data))
            return std::get<double>(m_data);
        if (PERMISSIVE_CAST && std::holds_alternative<int64_t>(m_data))
            return std::get<int64_t>(m_data);
        throw exceptions::invalid_cast(
            types::float_type, types::to_string(data_type()), EXC_INFO);
    }

    template <> inline bool DataNode::as() const
    {
        if (std::holds_alternative<bool>(m_data))
            return std::get<bool>(m_data);
        throw exceptions::invalid_cast(
            types::bool_type, types::to_string(data_type()), EXC_INFO);
    }

    template <> inline std::string DataNode::as() const
    {
        if (std::holds_alternative<std::string>(m_data))
            return std::get<std::string>(m_data);
        throw exceptions::invalid_cast(
            types::string_type, types::to_string(data_type()), EXC_INFO);
    }
}
